[Scia Reto](https://sciareto.org) mind map   
> __version__=`1.1`,generatorId=`com.igormaznitsa:idea-mindmap:intellij-2024.23.0-IntelliJ IDEA`
---

# 思维导图

## 文老师基础课程

### 1 计算机硬件
> collapsed=`true`


#### CPU
> collapsed=`true`


##### 运算器
> collapsed=`true`


###### 功能：数据处理，包括算术和逻辑运算。

###### 组成
> collapsed=`true`


####### 算术逻辑单元ALU

####### 累加寄存器AC：运算结果和源操作数

####### 数据缓冲寄存器DR：暂存内存的指令或数据

####### 状态条件寄存器PSW：溢出标志

##### 控制器
> collapsed=`true`


###### 功能：程序、操作、时间控制

###### 组成
> collapsed=`true`


####### 指令寄存器IR：暂存CPU的执行指令。

####### 程序计数器PC：存放指令执行地址。

####### 地址寄存器AR：保存当前CPU所访问的内存地址。

####### 指令译码器ID：分析指令操作码

##### CPU依据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段，指令会命令CPU分别去取指令或者数据。

##### CPU校验码
> collapsed=`true`


###### 奇偶校验码（检1位错，无法纠错）
> collapsed=`true`


####### 在编码中增加1位校验位来使编码中1的个数为奇数，码距是2。

###### CRC校验码（只能检错，不能纠错）
> collapsed=`true`


####### 先约定一个多项式G\(x\)，在原始信息位后追加若干个校验位，使得追加的信息能被G\(x\)整除。

####### 具体步骤如下：G\(x\)=x^4\+x\+1，r为4
> collapsed=`true`


######## 1\.得到被除数和除数
> collapsed=`true`


######### 在原始信息后增加r个0（被除数）

######### 根据x的幂次位为1的设置为1否则0，从右到左0\-4（除数）

######## 2\.生成CRC校验码：被除数和除数模2取余除法运算（不进位、不借位）相同为0，不同为1。余数不足r位，左边补0。

######## 3\.原始信息\+余数

###### 指令系统
> collapsed=`true`


####### 指令
> collapsed=`true`


######## 指令的组成：操作码\+地址码（操作数的地址）

######## 指令的执行过程：取指令（从PC取指令地址）——分析指令——执行指令

######## 指令寻址方式（找指令）
> collapsed=`true`


######### 顺序——PC存储指令；

######### 跳跃——地址由本条指令直接给出。

######## 指令操作的寻址方式（找操作数）
> collapsed=`true`


######### 立即——操作数本身（不需要访问主存）

######### 直接——操作数在主存中的地址，根据地址去主存中取出来

######### 间接——存的是（存主存地址）的地址，访问两次主存

######### 寄存器——存的是寄存器编码

####### 指令系统
> collapsed=`true`


######## CISC（复杂）
> collapsed=`true`


######### 实现方式微程序控制技术

######## RISC（精简）
> collapsed=`true`


######### 增加通用寄存器

######### 硬布线逻辑控制为主

######### 适合采用流水线

####### 流水线
> collapsed=`true`


######## 流水线周期：执行时间最长的段的时间。

######## 流水线执行时间=1条指令总执行时间\+\(总指令数\-1\)\*流水线周期

######## 流水线吞吐率=指令条数/流水线执行时间

######## 流水线加速比=不使用流水线执行时间/使用流水线执行时间。
> collapsed=`true`


######### 得出的最大加速比是无穷大可以去掉常数。

######## 1s = 10^9 ns

#### 存储器
> collapsed=`true`


##### 存储系统
> collapsed=`true`


###### 组成（从快到慢）
> collapsed=`true`


####### 通用寄存器

####### 高速缓存Cache
> collapsed=`true`


######## 高速缓存Cache：存储最活跃的程序和数据，直接与CPU交互，位于CPU和主存之间。

######## 组成
> collapsed=`true`


######### 控制部分
> collapsed=`true`


########## 判断CPU要访问的数据是否在Cache中，在则命中，不在则依据一定算法从主存中替换。

######### 存储器
> collapsed=`true`


########## 存储数据

######## 地址映射
> collapsed=`true`


######### 将主存地址转换为Cache存储器地址，地址转换称为地址映射（由硬件自动完成映射）

######### 三种方法
> collapsed=`true`


########## 直接：Cache寄存器分成块，主存也等分成块编号。映射关系固定。（容易浪费，有冲突）

########## 全相：Cache寄存器分成块，主存也等分成块编号。任意一块都与Cache任意一块对应。（最不容易发生块冲突，没有浪费）

########## 组组相：将Cache存储器先分块再分组，主存也先分块再分组。组之间（直接固定）、组内（全相任意）

######## Cache的替换算法：随机替换，先进先出，最近最少使用（局部性原理），优化替换（先执行程序，统计Cache替换情况）。

######## Cache命中率及平均时间=命中率 \* Cache时间\+\(1\-命中率\) \* 主存命中时间

####### 主存

####### 磁盘
> collapsed=`true`


######## 组成：磁盘有多个同心圆，每个同心圆是一个磁道，每个同心圆划分为多个扇区，数据存放在扇区中。

######## 工作原理：磁头先要找到对应的磁道，然后等待磁盘进行周期旋转，旋转道指定的扇区，才能读取到对应的数据。
> collapsed=`true`


######### 会产生寻道时间和等待时间。

######### 存取时间=寻道时间（磁头移动到磁道所需时间）\+等待时间（等待读写的扇区转到磁头下方所用的时间）

######## 磁盘调度算法：磁盘寻道时间耗时最长。
> collapsed=`true`


######### 先来先服务：访问磁盘的先后顺序

######### 最短寻道时间优先SSTF：离当前磁道最近的，会产生饥饿现象，某个磁道永远不会访问。

######### 扫描算法SCAN：在一个方向要全部移动完才掉头。（类似电梯）

######### 单向扫描CSCAN：只能单向。

#### 输入、输出设备
> collapsed=`true`


##### 输入/输出技术
> collapsed=`true`


###### 内存与接口地址道编址方法
> collapsed=`true`


####### 独立（接口指令少，功能弱）

####### 统一（用内存的指令全部可用接口，缺点地址空间不连续）

###### 计算机和外设的数据交互方式
> collapsed=`true`


####### 程序控制（查询）：CPU主动查询外设是否完成数据传输，效率极低。CPU\-Cache\-主存

####### 程序中断：外设完成数据传输后，向CPU发送中断，等待CPU处理数据，效率较高。
> collapsed=`true`


######## 中断响应时间：从发出中断请求到进入中断处理程序

######## 中断处理时间：从中断处理开始到中断处理结束

######## 中断向量提供中断服务程序的入口地址。

######## 多级中断嵌套，使用堆栈来保护断点和现场。

####### DMA方式（直接主存存取）
> collapsed=`true`


######## CPU只需要完成必要的初始化操作。

######## 数据传输的整个过程都由DMA控制器完成，在主存和外设之间建立直接的数据通路，效率很高。

######## 总线结构\-通道。

####### 在一个总线周期结束后，CPU会响应DMA请求开始读取数据；CPU响应程序中断请求方式请求是在一条指令执行结束时。

##### 总线
> collapsed=`true`


###### 总线是公共数据通道

###### 具体分类
> collapsed=`true`


####### 系统总线

####### 数据总线：并行数据传输数据位数

####### 地址总线：系统可管理内存空间大小。

####### 控制总线：传输控制指令

####### 其他总线
> collapsed=`true`


######## 串行总线RS232：一位一位发送，适合长距离，低速。

######## 并行总线SCSI：发送多条，速度快，只适合短距离。

######## 单总线：只有一条总线，多个设备共享。设计复杂。

######## 单工总线：只能在一个方向上传输信息。

######## 半双工总线：可以在两个方向上传输，同一时刻只能在一个方向上传输。

######## 全双工总线：可以在两个方向上传输，同意时刻能两个方向上传输。

### 2 操作系统
> collapsed=`true`


#### 操作系统概述
> collapsed=`true`


##### 操作系统：管理系统的软件和硬件资源。

##### 作用：管理软硬件资源，提供友善的人机界面，为应用开发提供高效率的平台。

##### 特征：并发性、共享性、虚拟性、不确定性（异步性）

#### 操作系统功能
> collapsed=`true`


##### 进程管理
> collapsed=`true`


###### 对CPU的执行时间进行管理，采用多道程序等技术，包括进程控制、进程同步、进程通信和进程调度。

###### 进程的组成
> collapsed=`true`


####### 进程控制块PCB（唯一标志）、程序（描述做什么）、数据（存放进程执行时所需数据）

###### 进程基础的状态：就绪、运行、阻塞

###### 前驱图：进程之间任务间的并行、任务间的先后顺序。

###### 进程资源图：进程和资源之间的分配和请求关系。
> collapsed=`true`


####### 表示
> collapsed=`true`


######## P进程，R资源。

######## 圆圈——资源个数。

######## 资源—\>进程：资源分配给了进程。

######## 进程—\>资源：表示进程还需要某个资源。

####### 阻塞节点：某进程所请求的资源已经被分配完了。没有资源分配给它。

####### 非阻塞节点：某进程所请求的资源还有剩余。

####### 当进程资源图所有进程都是阻塞节点，则死锁。

####### 是否可以化简（最后能否顺利执行完）：先执行非阻塞节点（同时释放资源），执行其他节点。

###### 进程的同步互斥
> collapsed=`true`


####### 临界资源：各个进程以互斥的方式访问的资源。

####### 临界区：对临界资源操作的那段程序。（代码）

####### 互斥：同一时间内只能由一个任务单独使用，需要加锁。

####### 同步：多个任务间可以并发执行。需要等待执行完。

####### 信号量的同步与互斥
> collapsed=`true`


######## 互斥：对临界资源互斥访问，初值为1，同时只能一个使用。

######## 同步：对共享资源访问的控制，初值事共享资源数量。同步：对共享资源访问的控制，初值事共享资源数量。

######## PV操作：
> collapsed=`true`


######### P\(s\)：申请资源，s=s\-1。s\>=0，则继续执行；s\<0，则阻塞该进程，并加入阻塞队列。

######### V\(s\)：释放资源，s=s\+1。s\>0则继续执行；s\<=0，则从阻塞队列中唤醒一个进程，并插入就绪队列。

######## 前趋图和信号量流程图操作题：前驱图一条线代表一个信号量。左边箭头是后面执行需要申请的资源。

###### 进程调度
> collapsed=`true`


####### 当有更高优先级的进程到来时如何分配CPU。分为可剥夺和不可剥夺。

####### 一个作业从提交到完成需要经历高、中、低三级调度。
> collapsed=`true`


######## 高级调度/长调度/作业调度/接纳调度
> collapsed=`true`


######### 决定处于输入池中哪个作业可以调入主系统做好运行的准备，成为一个或一组就绪进程。在系统中一个作业只需经过一次高级调度。

######## 中级调度/中程调度/对换调度
> collapsed=`true`


######### 处于交换区的哪个就绪进程可以掉入内存。

######## 低级调度/短程调度/进程调度
> collapsed=`true`


######### 处于内存中哪个就绪进程可以占用CPU。

####### 进程调度算法
> collapsed=`true`


######## 先来先服务，时间片轮转、优先级调度、多级反馈调度（时间片轮转\+优先级调度结合。设置多个就绪队列，每个队列不同的优先级，不同的时间片长度）

####### 死锁
> collapsed=`true`


######## 死锁概念：进程资源图所有节点都是阻塞节点。每个进程都在等待资源，资源又没有了。

######## 死锁产生的四个必要条件：资源互斥（不可改变）、每个进程占有资源并等待其他资源（定时器可改变）、系统不能剥夺进程资源（操作系统强制剥夺）、进程资源图是一个环路。

######## 打破四大条件
> collapsed=`true`


######### 死锁预防：破坏死锁产生的四大条件之一。定时器到时间释放资源，操作系统强制剥夺资源。

######### 死锁避免：银行家算法，提前计算出一条不会死锁的资源分配方法，才分配资源，否则不分配资源。

######### 死锁检测：定时检测死锁，检测到死锁，则死锁解除。

######### 死锁解除：死锁发生后的解除方法，如强制剥夺资源，撤销进程等。

######## 死锁资源计算：系统有n个进程，每个进程都需要R个资源，那么发生死锁的最大资源数为n\*\(R\-1\)，不发生死锁的最小资源数为n\*\(R\-1\)\+1

####### 线程
> collapsed=`true`


######## 引入线程的原因
> collapsed=`true`


######### 进程在创建、撤销、切换的开销大。

######### 进程在创建、撤销、切换的开销大。

######### 线程间的资源是共享的。

######## 线程是进程中的一个实体
> collapsed=`true`


######### 线程控制块TCB、程序计数器PC、一组寄存器、栈。

######### 与同属于一个进程的其他线程共享进程所拥有的全部资源。线程私有，进程共有。

##### 存储管理
> collapsed=`true`


###### 对主存储器空间进行管理，包括存储分配与回收、存储保护、地址映射和主存扩充。

###### 分区：整存，将某进程运行所需的内存整体一起分配给它。三种分区方式
> collapsed=`true`


####### 固定分区：分片固定，会产生内部碎片。

####### 可变分区：动态分区，不存在内部碎片，但容易整片主存空间切割成许多块，会产生外部碎片。
> collapsed=`true`


######## 假设当前内存分配好了，还需要分配9KB的空间，不同算法的结果有：

######## 首次适应：按内存地址顺序从头查找，找到第一个\>=9KB的空闲块，切割。

######## 最佳适应：满足条件且最小的。

######## 最差适应：满足条件且最大的。预防系统中产生过多的细小空闲块。

######## 循环首次适应：按内存地址顺序查找，找到第一个\>=9空闲块，如果还需分配，则找下一个，不需要从头查找。

####### 可重定位分区：可以解决碎片问题，移动所有已经分配好的区域，变成一个连续的区域。这样外部小分区碎片合并成大分区。

###### 分页（固定）
> collapsed=`true`


####### 逻辑页分为页号和页内地址，页内地址就是物理偏移地址，页号与物理块号对应关系需查询页表。
> collapsed=`true`


######## 物理块号\+偏移地址得出真正运行的物理地址。

####### 优点：碎片小，利用率高，分配及管理简单。

####### 缺点：增加系统开销，可能产生抖动现象。

####### 页面置换算法
> collapsed=`true`


######## 最优算法OPT（选择未来最长时间内不被访问的页面置换，理论上）、先进先出FIFO（抖动现象，页越多效率下降）、最近最少使用LRU（效率高，不会抖动）、淘汰原则（优先淘汰最近未访问的，而后淘汰最近未被修改的页面）

####### 快表（快速的页表）
> collapsed=`true`


######## 一块小容量的相联存储器，由快速存储器组成，按内容访问，速度快，访问最频繁的页号。

######## 快表是将页表存在Cache中；快表是访问一次Cache和一次内存，因此更快。

######## 慢表是将页表存在内存上，慢表需要访问两次内存才能取出页

####### 题：页面大小为偏移量，4K=2^12位，二进制12位=十六进制3位。因此逻辑地址1D16H可得出D16为偏移量，1为页号。

###### 分段（不固定）
> collapsed=`true`


####### 将进程分为一个个段，每段也有段号和段内地址，每段的物理大小不同，分段是根据逻辑整体分段的。
> collapsed=`true`


######## 段表有段长和基址才能确认物理地址。

####### 优点：多道程序共享内存。各段程序修改互不影响。

####### 缺点：内存利用率低，内存碎片浪费大。

####### 题目：逻辑地址（段号，偏移量），看看对应的偏移量是否在段长里。

###### 段页式：对进程先分段后分页。
> collapsed=`true`


####### 优点：空间浪费小，存储共享、保护容易，能动态链接。

####### 缺点：复杂开销增加。执行速度下降。

##### 设备管理
> collapsed=`true`


###### 对硬件设备的管理，包括对输入/输出设备的分配、启动、完成和回收。

###### I/O系统（负责管理设备和输入输出的机构）组成
> collapsed=`true`


####### 设备
> collapsed=`true`


######## 设备的分类：
> collapsed=`true`


######### 按数据组织分类：块、字符<br/>按照设备功能分类：输入、输出、存储、网络联网、供电<br/>资源分配角度分类：独占、共享、虚拟（虚设备，把独占设备转换成共享设备）<br/>数据传输速率分类：低速、中速、高速
> align=`left`


####### 控制器

####### 通道（具有通道的计算机系统）

####### 总线

####### I/O软件
> collapsed=`true`


######## I/O软件：输入输出的设备管理软件。
> collapsed=`true`


######### 分层
> collapsed=`true`


########## 用户进程：输入输出的调用<br/>设备无关软件：命名、保护、阻塞、缓冲、分配；检查高速缓存中有无要读取的块。<br/>设备驱动程序<br/>中断处理程序<br/>硬件
> align=`left`


###### 设备管理技术
> collapsed=`true`


####### 虚设备：虚拟设备。通过设备管理SPOOLING技术，把独占设备变成共享设备。

####### SPOOLING技术（外围设备联机操作）技术：在外设上建立两个数据缓冲区，分为输入输出井。把请求进入缓冲区，按照顺序打印。每个进程都感觉在使用一个打印机，物理设备的虚拟化。

##### 文件管理
> collapsed=`true`


###### 文件逻辑结构分为：有结构的记录式文件；无结构的流式文件。

###### 文件物理结构式指文件在物理存储设备上的存放方法。
> collapsed=`true`


####### 连续结构（顺序）：逻辑上连续的文件信息（如记录）依次放在连续编号的物理块上。

####### 链接结构（串联）：存放在不连续的物理块上，每个物理块设有一个指针指向下一个物理块。

####### 索引结构：系统为每个文件建立一张索引表。索引表记录了文件信息所在的逻辑块号对应的物理块号，并将索引表的起始地址放在与文件对应的文件目录项中。

####### 多个物理块的索引表：索引表是在文件创建时由系统自动建立的，并与文件一起存放在同一文件卷上。根据一个文件大小的不同，其索引表占用物理块的个数不同，一般占一个或多个物理块。

###### 索引文件结构（计算）
> collapsed=`true`


####### 直接索引：每个索引等节点直接指向物理盘块。假设0\-9为直接索引，每个物理盘块为4KB，则共可存4KB\*10=40KB数据。

####### 一级间接索引：直接指向的是直接索引。扩大了地址范围。假设10号为一级间接索引，大小为4KB，每个地址占4B，则共有4KB/4B=1024个地址，对应1024个物理盘，则可存1024\*4KB=4096KB的数据。

####### 二级索引：直接存放一级地址，一级地址存物理盘块地址。假设物理盘块大小4KB，索引地址占4B，则4KB/4B（二级地址） \* 4KB/4B（一级地址） \* 4KB（物理盘块大小） = 1024\* 1024 \* 4KB数据。

###### 文件目录
> collapsed=`true`


####### 绝对路径（\\开头然后\\当前目录）

####### 相对路径（不是\\开头）不包含文件名

####### 全文件名：绝对路径\+文件名

###### 文件存储空间管理
> collapsed=`true`


####### 空闲区表（连续的文件结构）

####### 位示图：每一位对应文件的物理块，0和1表示空闲和占用。1个磁盘块对应一个bit。字长xx，问需要多少字，磁盘块/字长=字。从0开始编号，513个是512块号。

####### 空闲块链（不连续的）

####### 成组链接法

##### 作业管理
> collapsed=`true`


###### 包括任务、界面管理、人机交互、图形界面、语音控制和虚拟现实等。

#### 操作系统分类
> collapsed=`true`


##### 批处理：单道（一次一个）、多道（一次多个）

##### 分时：将CPU的工作时间划分多个时间片，交替运行（并发）。对交互能力要求高

##### 实时：快速响应，对交互能力要求不高，要求可靠性。

##### 网络：联网计算机能方便有效的共享网络资源，提供各种服务、协议。三种模式包括
> collapsed=`true`


###### 集中模式（集中的计算机来共享）

###### 客户端/服务器模式（C/S）

###### 对等模式（P2P各个计算机平等的，即可以当客户端也可以当服务器）

##### 分布式：网络系统的升级，多个计算机分配位置不同。

##### 微型：Windows、MacOS

##### 嵌入式
> collapsed=`true`


###### 特点：微型化（占资源小）、可定制（针对硬件定制）、实时性、可靠性、易移植性。

###### 嵌入式系统初始化过程，按照从底向上、从硬件到软件次序为：片级初始化—\>板级初始化—\>系统初始化。

### 3 数据库

#### 三级模式\-两级映像

##### 三级模式

###### 内部模式

####### 内部模式（Internal Schema）\-存储文件：这是数据库的物理存储方式，它定义了数据在存储设备上的具体结构，如如何存储、索引、压缩和加密等。内部模式关注的是物理数据存储的细节。

###### 概念模式

####### 概念模式（Conceptual Schema）\-基本表：也称为逻辑模式，定义了整个数据库的结构和内容，无论数据的具体存储方式。这一层次描述了数据的逻辑关系，例如数据的实体、属性及其之间的关系。

###### 外部模式

####### 外部模式（External Schema）\-视图：又称为视图模式，定义了不同用户或应用程序对数据的不同视角或访问方式。每个外部模式可以为不同的用户提供相应的数据视图，以满足不同的需求。

##### 两级映像

###### 外部/概念映像（External\-Conceptional Mapping）：设计外部模式与概念模式之间的映射，以确保用户视图与数据库逻辑结构的正确对应。

###### 概念/内部映像（Conceptual\-Internal Mapping）：设计概念模式与内部模式之间的映射，以确保逻辑数据结构与物理存储结构的一致性。

##### 数据的独立性

###### 物理独立性（内模式）：用户和应用程序不需要关心数据的物理存储实现。

###### 逻辑独立性（外模式）：对数据逻辑结构的改变不会影响到外部模式。

#### 数据库设计

##### 需求分析（需求说明书、数据流图、数据字典）

###### 收集并分析用户需求。确定系统的功能需求和性能需求。

##### 概念设计（E\-R图/概念结构模型）

###### E\-R图（实体、属性、关系、约束条件）

##### 逻辑设计（逻辑结构模型/关系模式）

###### 关系模型（表）确定表的结构、主键、外键、索引等。

##### 物理设计（数据存储方式、访问方式）

###### 存储方式、访问方式。数据类型、存储方式和索引策略。

##### 实施（具体数据库和SQL）

###### 创建数据库，编写所需的SQL语句。

##### 维护与优化

###### 定期监控数据库性能，进行备份和恢复。根据使用情况进行优化和调整。

#### 数据模型三要素

#### 关系代数

#### 函数依赖

#### 范式

### 4 嵌入式
> collapsed=`true`


#### 嵌入式微处理器

#### 多核处理器

#### 嵌入式技术

#### 嵌入式软件

#### 嵌入式系统

#### RTOS

#### 软件开发

### 5 计算机网络
> collapsed=`true`


#### 七层模型

#### 局域网

#### TCP/IP协议族

#### 传输介质

#### 通信方式

#### IP地址

#### 子网划分

#### IPV6

#### 网络规划

#### 网络存储

#### 补充考点

### 6 其他计算机系统基础知识

### 7 系统配置与性能评价

### 8 信息系统
> collapsed=`true`


#### 概述

#### 生命周期

#### 开发方法

#### TPC

#### MIS

#### DSS

#### ES

#### OAS

#### ERP

#### 电子政务

#### 企业信息化

#### 信息战略化规划

#### CRO

#### SCM

#### 应用集成

#### 电子商务

### 9 系统安全
> collapsed=`true`


#### 信息安全基础

#### 技术体系

#### 加密技术

#### 摘要

#### 签名

#### PKI

#### 访问控制

#### DOS

#### 欺骗技术

#### 端口扫描

#### 安全体系

#### 网络安全技术和协议

### 10 软件工程
> collapsed=`true`


#### 软件工程概述

#### CMM

#### 软件过程模型

#### 逆向工程

#### 需求分析

#### 需求获取

#### 需求定义

#### 需求验证

#### 需求管理

#### 处理流程设计

#### 系统设计

#### 人机界面设计

#### 测试原则

#### 测试阶段

#### 测试用例设计

#### 调试

#### 系统转换

#### 系统维护

#### 净室软件工程

#### 基于构件

### 11 面向对象技术
> collapsed=`true`


#### 基本概念

#### 分析设计测试

#### 统一建模语言UML

#### 事务关系图

#### 设计模式

### 12 项目管理

### 13 系统架构设计
> collapsed=`true`


#### 软件架构概述

#### 构件技术

#### 软件架构风格

#### 补充 层次风格

#### SOA

#### 架构复用ODSSA

#### ABSD

#### 质量管理

#### 架构评估

#### 其他架构评估方法

#### 中间件

### 14 软件可靠性基础

### 15 软件架构的演化和维护

### 16 未来信息综合技术

### 17 补充：知识产权和标准化

### 18 补充数学
> collapsed=`true`


#### 生成树

#### 最短路径

#### 最大流量

#### 线性规划

#### 动态规划

#### 伏格尔法

#### 博弈论

#### 决策论

#### 排队论
